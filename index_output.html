<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<style>
    #input{
        display: none;
    }
    #output{
        display: block; 
        margin: 0 auto 1rem;
        width: 960px;
        height: 540;
        max-width: 100%;
        transform: scaleX(-1);
        transform-origin: center;
        
        background-color: black;
        opacity: 1;
    }
    output video{
      opacity: 0;
    }    
</style>
  <script>
    const channel = new BroadcastChannel("handDataChannel");
    let latestLandmarks = null;

    channel.onmessage = (event) => {
      if(event.data && event.data.landmarks) {
      latestLandmarks = event.data.landmarks[0];
      }
      if(typeof event.data.isPinching === "boolean"){
        isPinchingRemote = event.data.isPinching;
      }
    };
  </script>
</head>
<body>

  <div class="container">
    
    <!-- Webカメラの映像（入力） -->
    <video id="input"></video>
    
    <!--  認識した手の形状を可視化した映像（出力）  -->
    <canvas id="output" width="1920" height="1080"></canvas>
  </div>

  <script>    

    let isOutputFullscreen = false;
  
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');

    let isPinching = false;
    let wasPinching = false;
    let pointAlpha = 1.0;

    function renderFromReceivedData(){
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       if(!latestLandmarks || !Array.isArray(latestLandmarks)){
        requestAnimationFrame(renderFromReceivedData);
        console.log(latestLandmarks); 
        return;
       }
       const alpha = parseFloat(pointAlpha);
       if(latestLandmarks[4] && latestLandmarks[8]){
        ctx.beginPath();
        ctx.moveTo(latestLandmarks[4].x * canvas.width, latestLandmarks[4].y * canvas.height);
        ctx.lineTo(latestLandmarks[8].x * canvas.width, latestLandmarks[8].y * canvas.height);
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.lineWidth = 3;
        ctx.stroke();
       }
      for (let i = 0; i < latestLandmarks.length; i++) {
        const landmark = latestLandmarks[i];
        const x = landmark.x * canvas.width;
        const y = landmark.y * canvas.height;
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        if (i === 4 || i === 8) {
          ctx.fillStyle = `rgba(240, 0, 0, 1)`;
        } else {
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        }
        ctx.fill();
      }
      if (isPinchingRemote) {
        pointAlpha -= 0.1;
        if (pointAlpha < 0) pointAlpha = 0;
      } else {
        pointAlpha += 0.2;
        if (pointAlpha > 1) pointAlpha = 1;
      }
      requestAnimationFrame(renderFromReceivedData);
    }
  

    //認識開始・終了ボタン  
window.addEventListener("DOMContentLoaded", () => {
    renderFromReceivedData();
});

     
    document.addEventListener("keydown", event => {
      if(event.key == "Enter"){
        if(isRunning){
          camera.stop();
        }else{
          camera.start();
        }
      }
    });

    const output = document.getElementById("output");

    let isRunning = true;
        document.addEventListener("keydown", event => {
      if(event.key == "Enter"){
        if(isRunning){
          camera.stop();
          lostFrames = 0;
          isRunning = false;
        }else{
          camera.start();
        }
        isRunning = !isRunning
      }
    });

    document.addEventListener("keydown", event => {
      if (event.key == "d") {
        if (output.style.display === "none") {
          isOutputFullscreen = true;
          output.style.position = "fixed";
          output.style.top = 0;
          output.style.left = 0;
          output.style.width = "100vw";
          output.style.height = "100vh";
          output.style.zIndex = "9999";
          output.style.display = "block";
          output.classList.remove("hidden");
        } else {
          isOutputFullscreen = false;
          output.classList.add("hidden");
          output.style.display = "none";
        }
      }
    });
    
  


</script> 

</body>
</html>
