<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<style>
    #input{
        display: none;
    }
    #output{
        display: block; 
        margin: 0 auto 1rem;
        width: 960px;
        height: 540;
        max-width: 100%;
        transform: scaleX(-1);
        transform-origin: center;
        
        background-color: black;
        opacity: 1;
    }
    output video{
      opacity: 0;
    }

    
</style>
  <!-- 3つのライブラリを読み込む -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <!-- SVG Path Properties for curved seekbars -->
  <script src="https://cdn.jsdelivr.net/npm/svg-path-properties@1.0.3/dist/svg-path-properties.min.js"></script>
</head>
<body>

  <div class="container">
    
    <!-- Webカメラの映像（入力） -->
    <video id="input"></video>
    
    <!--  認識した手の形状を可視化した映像（出力）  -->
    <canvas id="output" width="1920" height="1080"></canvas>
  </div>

  <script>    

    let isOutputFullscreen = false;
  
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');

    let isPinching = false;
    let wasPinching = false;
    let pointAlpha = 1.0;

    // スムージング用変数と係数
    let smoothedIndexPosX = 0;
    let smoothedIndexPosY = 0;
    const smoothingAlpha = 0.15; // 大きいほど追従速く、小さいほど滑らか
    
    //関連ファイルの読み込み
    const config = {
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    };
    const hands = new Hands(config);

    //カメラからの映像をhands.jsで使えるようにする
    const video = document.getElementById("input");
    const camera = new Camera(video, {
      onFrame: async () => {
        await hands.send({image: video});
      },
      width: 1920,
      height: 1080,
      frameRate: 60
    });

    hands.setOptions({
        maxNumHands: 1,              //検出する手の最大数
        modelComplexity: 1,          //ランドマーク検出精度(0か1)
        minDetectionConfidence: 0.3, //手を検出するための信頼値(0.0~1.0)　ここ0にしたら面白そう
        minTrackingConfidence: 0.2   //ランドマーク追跡の信頼度(0.0~1.0)
    });


    //形状認識した結果の取得
    hands.onResults(results => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      //ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if(
        results.multiHandLandmarks &&
        results.multiHandLandmarks.length > 0 &&
        results.multiHandLandmarks[0] &&
        results.multiHandLandmarks[0].length > 8
      ) {
        const start = results.multiHandLandmarks[0][4];
        const end = results.multiHandLandmarks[0][8];
        const alpha = parseFloat(pointAlpha);

       

        ctx.beginPath();
        ctx.moveTo(start.x * canvas.width, start.y * canvas.height);
        ctx.lineTo(end.x * canvas.width, end.y * canvas.height);
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
         console.log("pointAlpha: ",pointAlpha);
        ctx.lineWidth = 3;
        ctx.stroke();
      }
          if(isPinching) {
            pointAlpha -= 0.2;
            if(pointAlpha < 0) pointAlpha = 0;
          } else {
            pointAlpha += 0.2;
            if(pointAlpha > 1) pointAlpha = 1;
          }



      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        lostFrames = 0;
       
        for (const landmarks of results.multiHandLandmarks) {
          const alpha = parseFloat(pointAlpha);
          for (let i = 0; i < landmarks.length; i++) {
            const landmark = landmarks[i];
            const x = landmark.x * canvas.width;
            const y = landmark.y * canvas.height;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            if (i === 4 || i === 8) {

              ctx.fillStyle = `rgba(240, 0, 0)`; 
            } else {
              ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            }
            ctx.fill();
          }
      }
        ctx.restore();
       


        results.multiHandLandmarks.forEach(marks => {

          // 指先の座標取得
          const fingPosX = marks[8].x;
          const fingPosY = marks[8].y;
          const fingPosX2 = marks[4].x;
          const fingPosY2 = marks[4].y;
          const fingPosZ = marks[8].z;

          // スムージング用履歴管理
          if (!Array.isArray(window.historyY4)) window.historyY4 = [];
          if (!Array.isArray(window.historyY8)) window.historyY8 = [];
          if (!Array.isArray(window.historyX4)) window.historyX4 = [];
          if (!Array.isArray(window.historyX8)) window.historyX8 = [];

          let historyY4 = window.historyY4;
          let historyY8 = window.historyY8;
          let historyX4 = window.historyX4;
          let historyX8 = window.historyX8;

          const historyLength = 9;
          historyY4.push(fingPosY2);
          historyY8.push(fingPosY);
          if (historyY4.length > historyLength) historyY4.shift();
          if (historyY8.length > historyLength) historyY8.shift();
          const avgY4 = historyY4.reduce((a, b) => a + b, 0) / historyY4.length;
          const avgY8 = historyY8.reduce((a, b) => a + b, 0) / historyY8.length;

          historyX4.push(fingPosX2);
          historyX8.push(fingPosX);
          if(historyX4.length > historyLength) historyX4.shift();
          if(historyX8.length > historyLength) historyX8.shift();
          const avgX4 = historyX4.reduce((a, b) => a + b, 0) / historyX4.length;
          const avgX8 = historyX8.reduce((a, b) => a + b, 0) / historyX8.length;

          const rawX = (fingPosX + fingPosX2) / 2;
          const rawY = (fingPosY + fingPosY2) / 2;
          smoothedIndexPosX = smoothingAlpha * rawX + (1 - smoothingAlpha) * smoothedIndexPosX;
          smoothedIndexPosY = smoothingAlpha * rawY + (1 - smoothingAlpha) * smoothedIndexPosY;
          const smoothPosX = smoothedIndexPosX;
          const smoothPosY = smoothedIndexPosY;

          const dx = fingPosX - fingPosX2;
          const dy = fingPosY - fingPosY2;
          const distance = Math.hypot(dx, dy);
          const tikasa = 0.08;

          // ピンチ判定
          if (distance < tikasa) {
            if (!isPinching) {
              isPinching = true;
              wasPinching = true;
            }
          } else {
            isPinching = false;
          }
        

if(isOutputFullscreen) return;


        }); // forEach
      } else { // 指が消えたら
        isPinching = false;
        wasPinching = false;
      }

    }); // hands.onResults
  
  
    

    //認識開始・終了ボタン
    /* document.getElementById('start')
      .addEventListener('click', () => camera.start()); */
      
window.addEventListener("DOMContentLoaded", () => {
    camera.start();
    // 初期状態を「d 押下時」の状態に設定：検知画面を非表示、videoFootageとdualContainerを中央に配置・拡大
    const output = document.getElementById("output");
    
});

     
    document.addEventListener("keydown", event => {
      if(event.key == "Enter"){
        if(isRunning){
          camera.stop();
        }else{
          camera.start();
        }
      }
    });

    const output = document.getElementById("output");

    let isRunning = true;
        document.addEventListener("keydown", event => {
      if(event.key == "Enter"){
        if(isRunning){
          camera.stop();
          lostFrames = 0;
          isRunning = false;
        }else{
          camera.start();
        }
        isRunning = !isRunning
      }
    });

    document.addEventListener("keydown", event => {
      if (event.key == "d") {
        if (output.style.display === "none") {
          isOutputFullscreen = true;
          output.style.position = "fixed";
          output.style.top = 0;
          output.style.left = 0;
          output.style.width = "100vw";
          output.style.height = "100vh";
          output.style.zIndex = "9999";
          output.style.display = "block";
          output.classList.remove("hidden");
        } else {
          isOutputFullscreen = false;
          output.classList.add("hidden");
          output.style.display = "none";
        }
      }
    });
    
  


</script> 

</body>
</html>
